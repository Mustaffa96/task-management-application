{"ast":null,"code":"import { BehaviorSubject, throwError } from 'rxjs';\nimport { catchError, tap } from 'rxjs/operators';\nimport { environment } from '@environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@angular/router\";\n/**\n * Authentication service\n * Manages user authentication state and API communication\n */\nexport class AuthService {\n  /**\n   * Constructor\n   * @param http HttpClient for API requests\n   * @param router Angular router for navigation\n   */\n  constructor(http, router) {\n    this.http = http;\n    this.router = router;\n    /**\n     * BehaviorSubject to track and broadcast the current user state\n     * Initialized as null (not authenticated)\n     */\n    this.userSubject = new BehaviorSubject(null);\n    /**\n     * Observable of the current user state\n     * Components can subscribe to this to react to auth state changes\n     */\n    this.user = this.userSubject.asObservable();\n    /**\n     * API URL for authentication endpoints\n     */\n    this.apiUrl = `${environment.apiUrl}/auth`;\n  }\n  /**\n   * Register a new user\n   * @param registerData User registration data\n   * @returns Observable of the registration response\n   */\n  register(registerData) {\n    return this.http.post(`${this.apiUrl}/register`, registerData).pipe(tap(response => {\n      // Auto-login after successful registration\n      this.handleAuthentication(response);\n    }), catchError(this.handleError));\n  }\n  /**\n   * Login an existing user\n   * @param loginData User login credentials\n   * @returns Observable of the login response\n   */\n  login(loginData) {\n    return this.http.post(`${this.apiUrl}/login`, loginData, {\n      // Include credentials to allow cookies to be sent/received\n      withCredentials: true\n    }).pipe(tap(response => {\n      this.handleAuthentication(response);\n    }), catchError(this.handleError));\n  }\n  /**\n   * Logout the current user\n   * Clears the user state and redirects to login\n   */\n  logout() {\n    // Call the logout endpoint to clear server-side session/cookies\n    this.http.post(`${this.apiUrl}/logout`, {}, {\n      withCredentials: true\n    }).subscribe({\n      next: () => {\n        // Clear user state\n        this.userSubject.next(null);\n        // Clear any stored user data\n        localStorage.removeItem('userData');\n        // Redirect to login page\n        this.router.navigate(['/login']);\n      },\n      error: error => {\n        console.error('Logout error:', error);\n        // Even if the API call fails, clear local state\n        this.userSubject.next(null);\n        localStorage.removeItem('userData');\n        this.router.navigate(['/login']);\n      }\n    });\n  }\n  /**\n   * Attempt to automatically login the user from stored data\n   * Called on application startup\n   */\n  autoLogin() {\n    // Check if we have stored user data\n    const userData = localStorage.getItem('userData');\n    if (!userData) {\n      return;\n    }\n    // Parse the stored user data\n    const user = JSON.parse(userData);\n    if (user) {\n      // Update the user subject with the stored user\n      this.userSubject.next(user);\n      // Verify the token is still valid with the server\n      this.verifyToken();\n    }\n  }\n  /**\n   * Verify if the current token is still valid\n   */\n  verifyToken() {\n    this.http.get(`${this.apiUrl}/refresh`, {\n      withCredentials: true\n    }).subscribe({\n      next: response => {\n        // Update user data with fresh data from server\n        this.handleAuthentication(response);\n      },\n      error: () => {\n        // Token is invalid, logout the user\n        this.logout();\n      }\n    });\n  }\n  /**\n   * Get the current user value\n   * @returns The current user or null if not authenticated\n   */\n  getCurrentUser() {\n    return this.userSubject.value;\n  }\n  /**\n   * Check if the user is authenticated\n   * @returns True if user is authenticated, false otherwise\n   */\n  isAuthenticated() {\n    return !!this.userSubject.value;\n  }\n  /**\n   * Check if the user has a specific role\n   * @param role Role to check for\n   * @returns True if user has the role, false otherwise\n   */\n  hasRole(role) {\n    const user = this.userSubject.value;\n    return !!user && user.role === role;\n  }\n  /**\n   * Handle successful authentication\n   * @param response Authentication response from API\n   */\n  handleAuthentication(response) {\n    // Create user object from response\n    const user = {\n      id: response.id,\n      name: response.name,\n      email: response.email,\n      role: response.role,\n      token: response.token\n    };\n    // Update the user subject\n    this.userSubject.next(user);\n    // Store user data in localStorage for auto-login\n    localStorage.setItem('userData', JSON.stringify(user));\n  }\n  /**\n   * Handle API errors\n   * @param error Error from API\n   * @returns Observable error\n   */\n  handleError(error) {\n    let errorMessage = 'An unknown error occurred!';\n    if (error.error && error.error.message) {\n      errorMessage = error.error.message;\n    } else if (error.message) {\n      errorMessage = error.message;\n    }\n    return throwError(() => new Error(errorMessage));\n  }\n  static {\n    this.ɵfac = function AuthService_Factory(t) {\n      return new (t || AuthService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.Router));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AuthService,\n      factory: AuthService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["BehaviorSubject","throwError","catchError","tap","environment","AuthService","constructor","http","router","userSubject","user","asObservable","apiUrl","register","registerData","post","pipe","response","handleAuthentication","handleError","login","loginData","withCredentials","logout","subscribe","next","localStorage","removeItem","navigate","error","console","autoLogin","userData","getItem","JSON","parse","verifyToken","get","getCurrentUser","value","isAuthenticated","hasRole","role","id","name","email","token","setItem","stringify","errorMessage","message","Error","i0","ɵɵinject","i1","HttpClient","i2","Router","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Asus\\Documents\\GitHub\\task-management-application\\client\\src\\app\\core\\services\\auth.service.ts"],"sourcesContent":["/**\n * Authentication service\n * Handles user authentication, registration, and session management\n */\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, Observable, throwError } from 'rxjs';\nimport { catchError, tap } from 'rxjs/operators';\n\nimport { environment } from '@environments/environment';\nimport { User } from '../models/user.model';\nimport { AuthResponse, LoginRequest, RegisterRequest } from '../models/auth.model';\n\n/**\n * Authentication service\n * Manages user authentication state and API communication\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  /**\n   * BehaviorSubject to track and broadcast the current user state\n   * Initialized as null (not authenticated)\n   */\n  private userSubject = new BehaviorSubject<User | null>(null);\n  \n  /**\n   * Observable of the current user state\n   * Components can subscribe to this to react to auth state changes\n   */\n  user = this.userSubject.asObservable();\n  \n  /**\n   * API URL for authentication endpoints\n   */\n  private apiUrl = `${environment.apiUrl}/auth`;\n  \n  /**\n   * Constructor\n   * @param http HttpClient for API requests\n   * @param router Angular router for navigation\n   */\n  constructor(\n    private http: HttpClient,\n    private router: Router\n  ) {}\n  \n  /**\n   * Register a new user\n   * @param registerData User registration data\n   * @returns Observable of the registration response\n   */\n  register(registerData: RegisterRequest): Observable<AuthResponse> {\n    return this.http.post<AuthResponse>(`${this.apiUrl}/register`, registerData)\n      .pipe(\n        tap(response => {\n          // Auto-login after successful registration\n          this.handleAuthentication(response);\n        }),\n        catchError(this.handleError)\n      );\n  }\n  \n  /**\n   * Login an existing user\n   * @param loginData User login credentials\n   * @returns Observable of the login response\n   */\n  login(loginData: LoginRequest): Observable<AuthResponse> {\n    return this.http.post<AuthResponse>(`${this.apiUrl}/login`, loginData, {\n      // Include credentials to allow cookies to be sent/received\n      withCredentials: true\n    }).pipe(\n      tap(response => {\n        this.handleAuthentication(response);\n      }),\n      catchError(this.handleError)\n    );\n  }\n  \n  /**\n   * Logout the current user\n   * Clears the user state and redirects to login\n   */\n  logout(): void {\n    // Call the logout endpoint to clear server-side session/cookies\n    this.http.post(`${this.apiUrl}/logout`, {}, { withCredentials: true })\n      .subscribe({\n        next: () => {\n          // Clear user state\n          this.userSubject.next(null);\n          \n          // Clear any stored user data\n          localStorage.removeItem('userData');\n          \n          // Redirect to login page\n          this.router.navigate(['/login']);\n        },\n        error: (error) => {\n          console.error('Logout error:', error);\n          \n          // Even if the API call fails, clear local state\n          this.userSubject.next(null);\n          localStorage.removeItem('userData');\n          this.router.navigate(['/login']);\n        }\n      });\n  }\n  \n  /**\n   * Attempt to automatically login the user from stored data\n   * Called on application startup\n   */\n  autoLogin(): void {\n    // Check if we have stored user data\n    const userData = localStorage.getItem('userData');\n    \n    if (!userData) {\n      return;\n    }\n    \n    // Parse the stored user data\n    const user: User = JSON.parse(userData);\n    \n    if (user) {\n      // Update the user subject with the stored user\n      this.userSubject.next(user);\n      \n      // Verify the token is still valid with the server\n      this.verifyToken();\n    }\n  }\n  \n  /**\n   * Verify if the current token is still valid\n   */\n  private verifyToken(): void {\n    this.http.get<AuthResponse>(`${this.apiUrl}/refresh`, { withCredentials: true })\n      .subscribe({\n        next: (response) => {\n          // Update user data with fresh data from server\n          this.handleAuthentication(response);\n        },\n        error: () => {\n          // Token is invalid, logout the user\n          this.logout();\n        }\n      });\n  }\n  \n  /**\n   * Get the current user value\n   * @returns The current user or null if not authenticated\n   */\n  getCurrentUser(): User | null {\n    return this.userSubject.value;\n  }\n  \n  /**\n   * Check if the user is authenticated\n   * @returns True if user is authenticated, false otherwise\n   */\n  isAuthenticated(): boolean {\n    return !!this.userSubject.value;\n  }\n  \n  /**\n   * Check if the user has a specific role\n   * @param role Role to check for\n   * @returns True if user has the role, false otherwise\n   */\n  hasRole(role: string): boolean {\n    const user = this.userSubject.value;\n    return !!user && user.role === role;\n  }\n  \n  /**\n   * Handle successful authentication\n   * @param response Authentication response from API\n   */\n  private handleAuthentication(response: AuthResponse): void {\n    // Create user object from response\n    const user: User = {\n      id: response.id,\n      name: response.name,\n      email: response.email,\n      role: response.role,\n      token: response.token\n    };\n    \n    // Update the user subject\n    this.userSubject.next(user);\n    \n    // Store user data in localStorage for auto-login\n    localStorage.setItem('userData', JSON.stringify(user));\n  }\n  \n  /**\n   * Handle API errors\n   * @param error Error from API\n   * @returns Observable error\n   */\n  private handleError(error: any): Observable<never> {\n    let errorMessage = 'An unknown error occurred!';\n    \n    if (error.error && error.error.message) {\n      errorMessage = error.error.message;\n    } else if (error.message) {\n      errorMessage = error.message;\n    }\n    \n    return throwError(() => new Error(errorMessage));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}